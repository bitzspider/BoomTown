<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>World Map Viewer</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #1e1e1e;
            color: white;
            font-family: system-ui, -apple-system, sans-serif;
        }
        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
        .panel {
            position: fixed;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 8px;
            z-index: 1000;
        }
        #toolbox {
            top: 20px;
            left: 20px;
            width: 300px;
            max-height: 400px;
            overflow-y: auto;
            padding: 8px;
        }
        #controls {
            top: 20px;
            right: 20px;
            min-width: 250px;
        }
        .control-group {
            margin-bottom: 15px;
        }
        h2 {
            margin: 0 0 15px 0;
            color: #4CAF50;
        }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: #45a049;
        }
        #status {
            margin-top: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 4px;
        }
        .grid-toggle {
            display: flex;
            align-items: center;
            margin: 10px 0;
        }
        .grid-toggle input[type="checkbox"] {
            margin-right: 10px;
        }
        #gridSize {
            width: 60px;
            padding: 5px;
            margin-left: 10px;
        }
        .tool-item {
            display: flex;
            align-items: center;
            padding: 8px;
            margin: 4px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        .tool-item:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        .tool-item.selected {
            background: #4CAF50;
        }
        .tool-item img {
            width: 32px;
            height: 32px;
            margin-right: 10px;
            background: #333;
            border-radius: 4px;
        }
        .tool-category {
            margin: 15px 0;
        }
        .tool-category-title {
            font-weight: bold;
            color: #4CAF50;
            margin-bottom: 8px;
        }
        #selection-info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            display: none;
        }
        .info-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
        }
        .key-hint {
            color: #888;
            font-size: 0.9em;
        }
        .map-select {
            width: 100%;
            padding: 8px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            border: 1px solid #4CAF50;
            border-radius: 4px;
            margin-bottom: 10px;
            cursor: pointer;
        }
        .map-select option {
            background: #1e1e1e;
            color: white;
        }
        .save-input {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 4px;
        }
        .save-input input {
            flex: 1;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #4CAF50;
            border-radius: 4px;
            color: white;
        }
        .toolbox-item {
            padding: 8px;
            margin: 4px;
            background-color: #f0f0f0;
            border: 1px solid #ccc;
            border-radius: 4px;
            cursor: move;
            user-select: none;
        }
        .toolbox-item:hover {
            background-color: #e0e0e0;
        }
    </style>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
    
    <!-- Toolbox Panel -->
    <div id="toolbox" class="panel">
        <h2>üõ†Ô∏è Toolbox</h2>
        <div id="tool-categories"></div>
    </div>

    <!-- Controls Panel -->
    <div id="controls" class="panel">
        <h2>üó∫Ô∏è Map Controls</h2>
        <div class="control-group">
            <select id="mapSelect" class="map-select">
                <option value="map_data.json">Demo Map</option>
            </select>
            <button id="loadMapBtn">Load Map</button>
            <button id="reloadMapBtn">Reload</button>
        </div>
        <div class="control-group">
            <div class="save-input">
                <input type="text" id="saveMapName" placeholder="Map name" value="Demo Map">
                <button id="saveMapBtn">Save Map</button>
            </div>
        </div>
        <div class="control-group">
            <div class="grid-toggle">
                <input type="checkbox" id="showGrid" checked>
                <label for="showGrid">Show Grid</label>
                <input type="number" id="gridSize" value="2" min="1" max="10" step="0.5">
            </div>
        </div>
        <div id="status">Ready to load map...</div>
    </div>

    <!-- Selection Info Panel -->
    <div id="selection-info">
        <h3>Selected Object</h3>
        <div class="info-row">
            <span>ID: </span>
            <span id="selected-id"></span>
        </div>
        <div class="info-row">
            <span>Position: </span>
            <span id="selected-position"></span>
        </div>
        <div class="info-row">
            <span>Rotation: </span>
            <span id="selected-rotation"></span>
        </div>
        <div class="key-hint">
            Arrow keys: Move object | Shift + Arrow keys: Rotate object
        </div>
    </div>

    <!-- Load BabylonJS -->
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
    
    <!-- Load Yuka -->
    <script src="https://cdn.jsdelivr.net/npm/yuka@0.7.8/build/yuka.min.js"></script>
    
    <!-- Load our scripts -->
    <script src="js/map_engine.js"></script>
    
    <script>
        // Global variables
        let engine, scene, camera;
        let mapEngine;
        let ground, gridMaterial;
        let canvas;
        let selectedTool = null;
        let selectedObject = null;
        let isShiftPressed = false;

        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        async function initToolbox() {
            const toolContainer = document.getElementById('tool-categories');
            toolContainer.innerHTML = '<h2>üõ†Ô∏è Loading models...</h2>';
            
            try {
                const response = await fetch('/list-models');
                if (!response.ok) {
                    throw new Error('Failed to fetch models');
                }
                const data = await response.json();
                
                // Clear the loading message
                toolContainer.innerHTML = '';
                
                // Create a map of categories
                const categories = {
                    'Characters': data.models.filter(m => m.toLowerCase().includes('character')),
                    'Structures': data.models.filter(m => m.toLowerCase().includes('structure') || m.toLowerCase().includes('container')),
                    'Barriers': data.models.filter(m => m.toLowerCase().includes('barrier')),
                    'Environment': data.models.filter(m => m.toLowerCase().includes('tree') || m.toLowerCase().includes('debris')),
                    'Props': data.models.filter(m => 
                        m.toLowerCase().includes('barrel') || 
                        m.toLowerCase().includes('tank') || 
                        m.toLowerCase().includes('crate')
                    ),
                    'Other': data.models.filter(m => 
                        !m.toLowerCase().includes('character') &&
                        !m.toLowerCase().includes('structure') &&
                        !m.toLowerCase().includes('container') &&
                        !m.toLowerCase().includes('barrier') &&
                        !m.toLowerCase().includes('tree') &&
                        !m.toLowerCase().includes('debris') &&
                        !m.toLowerCase().includes('barrel') &&
                        !m.toLowerCase().includes('tank') &&
                        !m.toLowerCase().includes('crate')
                    )
                };
                
                // Create category sections
                Object.entries(categories).forEach(([category, models]) => {
                    if (models.length === 0) return; // Skip empty categories
                    
                    const categoryDiv = document.createElement('div');
                    categoryDiv.className = 'tool-category';
                    
                    const titleDiv = document.createElement('div');
                    titleDiv.className = 'tool-category-title';
                    titleDiv.textContent = category;
                    categoryDiv.appendChild(titleDiv);
                    
                    models.forEach(model => {
                        const toolItem = document.createElement('div');
                        toolItem.className = 'tool-item';
                        toolItem.innerHTML = `
                            <img src="/icons/model-icon.png" alt="${model}">
                            <span>${model.replace('.glb', '').replace('.gltf', '')}</span>
                        `;
                        
                        toolItem.addEventListener('click', () => {
                            document.querySelectorAll('.tool-item').forEach(item => {
                                item.classList.remove('selected');
                            });
                            toolItem.classList.add('selected');
                            selectedTool = model;
                        });
                        
                        categoryDiv.appendChild(toolItem);
                    });
                    
                    toolContainer.appendChild(categoryDiv);
                });
            } catch (error) {
                console.error('Error loading models:', error);
                toolContainer.innerHTML = '<h2>üõ†Ô∏è Error loading models</h2>';
                document.getElementById('status').textContent = 'Error loading models: ' + error.message;
                document.getElementById('status').style.color = '#ff4444';
            }
        }

        function updateSelectionInfo() {
            const infoPanel = document.getElementById('selection-info');
            if (selectedObject) {
                document.getElementById('selected-id').textContent = selectedObject.id;
                document.getElementById('selected-position').textContent = 
                    `X: ${selectedObject.position.x.toFixed(2)}, Z: ${selectedObject.position.z.toFixed(2)}`;
                document.getElementById('selected-rotation').textContent = 
                    `${(selectedObject.rotation.y * 180 / Math.PI).toFixed(0)}¬∞`;
                infoPanel.style.display = 'block';
            } else {
                infoPanel.style.display = 'none';
            }
        }

        function handleKeyboardInput(event) {
            if (selectedObject) {
                // Handle Delete key
                if (event.key === 'Delete') {
                    if (confirm(`Are you sure you want to delete object "${selectedObject.id}"?`)) {
                        console.log('Deleting object:', selectedObject.id);
                        mapEngine.removeObject(selectedObject.id);
                        selectedObject = null;
                        updateSelectionInfo();
                        camera.attachControl(canvas, true);
                    }
                    return;
                }

                // Prevent default behavior to stop camera movement
                event.preventDefault();

                const moveStep = 1;
                const rotateStep = Math.PI / 8;
                let positionChanged = false;
                let rotationChanged = false;

                if (event.shiftKey) {
                    isShiftPressed = true;
                    if (event.key === 'ArrowLeft') {
                        selectedObject.rotation.y += rotateStep;
                        rotationChanged = true;
                    } else if (event.key === 'ArrowRight') {
                        selectedObject.rotation.y -= rotateStep;
                        rotationChanged = true;
                    }
                } else {
                    switch(event.key) {
                        case 'ArrowLeft':
                            selectedObject.position.x -= moveStep;
                            positionChanged = true;
                            break;
                        case 'ArrowRight':
                            selectedObject.position.x += moveStep;
                            positionChanged = true;
                            break;
                        case 'ArrowUp':
                            selectedObject.position.z -= moveStep;
                            positionChanged = true;
                            break;
                        case 'ArrowDown':
                            selectedObject.position.z += moveStep;
                            positionChanged = true;
                            break;
                    }
                }

                // Only update if position or rotation changed
                if (positionChanged || rotationChanged) {
                    // Find and update the object in mapData
                    if (mapEngine.mapData && mapEngine.mapData.objects) {
                        const objectIndex = mapEngine.mapData.objects.findIndex(obj => obj.id === selectedObject.id);
                        if (objectIndex !== -1) {
                            console.log('Before update - Object data:', JSON.stringify(mapEngine.mapData.objects[objectIndex], null, 2));
                            
                            // Update the object data
                            mapEngine.mapData.objects[objectIndex] = {
                                ...mapEngine.mapData.objects[objectIndex],
                                position: {
                                    x: selectedObject.position.x,
                                    y: selectedObject.position.y,
                                    z: selectedObject.position.z
                                },
                                rotation: {
                                    x: BABYLON.Tools.ToDegrees(selectedObject.rotation.x),
                                    y: BABYLON.Tools.ToDegrees(selectedObject.rotation.y),
                                    z: BABYLON.Tools.ToDegrees(selectedObject.rotation.z)
                                }
                            };

                            console.log('After update - Object data:', JSON.stringify(mapEngine.mapData.objects[objectIndex], null, 2));
                            console.log('Full map data objects array:', JSON.stringify(mapEngine.mapData.objects, null, 2));
                        } else {
                            console.warn('Object not found in mapData:', selectedObject.id);
                        }
                    }
                }

                updateSelectionInfo();
            }
        }

        const createScene = () => {
            scene = new BABYLON.Scene(engine);
            
            // Camera setup
            camera = new BABYLON.ArcRotateCamera(
                'camera',
                BABYLON.Tools.ToRadians(45),
                BABYLON.Tools.ToRadians(45),
                20,
                BABYLON.Vector3.Zero(),
                scene
            );
            camera.attachControl(canvas, true);
            camera.lowerRadiusLimit = 5;
            camera.upperRadiusLimit = 100;
            camera.setTarget(BABYLON.Vector3.Zero());
            
            // Add some ambient light
            const ambientLight = new BABYLON.HemisphericLight(
                'ambientLight',
                new BABYLON.Vector3(0, 1, 0),
                scene
            );
            ambientLight.intensity = 1;
            
            // Add directional light for shadows
            const dirLight = new BABYLON.DirectionalLight(
                'dirLight',
                new BABYLON.Vector3(-1, -2, -1),
                scene
            );
            dirLight.intensity = 0.5;
            
            // Ground setup with picking
            ground = BABYLON.MeshBuilder.CreateGround('ground', {
                width: 100,
                height: 100,
                subdivisions: 100
            }, scene);
            
            ground.actionManager = new BABYLON.ActionManager(scene);
            ground.actionManager.registerAction(
                new BABYLON.ExecuteCodeAction(
                    BABYLON.ActionManager.OnPickTrigger,
                    (evt) => {
                        if (selectedTool) {
                            const pickResult = scene.pick(scene.pointerX, scene.pointerY);
                            if (pickResult.hit && pickResult.pickedMesh === ground) {
                                const worldPos = pickResult.pickedPoint;
                                console.log('Picked position:', worldPos);
                                const id = `${selectedTool.replace('.glb', '')}_${generateUUID()}`;
                                mapEngine.addObject({
                                    id: id,
                                    model: selectedTool,
                                    position: { 
                                        x: worldPos.x, 
                                        y: 0, 
                                        z: worldPos.z 
                                    },
                                    rotation: { x: 0, y: 0, z: 0 },
                                    scale: { x: 1, y: 1, z: 1 }
                                });
                            }
                        }
                    }
                )
            );
            
            // Grid material
            gridMaterial = new BABYLON.GridMaterial('groundMat', scene);
            gridMaterial.majorUnitFrequency = 5;
            gridMaterial.minorUnitVisibility = 0.45;
            gridMaterial.gridRatio = 1;
            gridMaterial.mainColor = new BABYLON.Color3(0.2, 0.2, 0.3);
            gridMaterial.lineColor = new BABYLON.Color3(0.3, 0.3, 0.4);
            ground.material = gridMaterial;

            // Setup object picking
            scene.onPointerDown = (evt, pickResult) => {
                if (evt.button === 0) { // Left click
                    console.log('Click detected');
                    
                    if (pickResult.hit && pickResult.pickedMesh !== ground) {
                        const pickedMesh = pickResult.pickedMesh;
                        console.log('Picked mesh:', {
                            id: pickedMesh.id,
                            name: pickedMesh.name,
                            metadata: pickedMesh.metadata
                        });

                        // Get the ID either from metadata (for child meshes) or directly (for root)
                        const objectId = pickedMesh.metadata?.parentId || pickedMesh.id;
                        
                        if (mapEngine.instances.has(objectId)) {
                            selectedObject = mapEngine.instances.get(objectId);
                            console.log('Selected object:', {
                                id: objectId,
                                position: selectedObject.position,
                                rotation: selectedObject.rotation
                            });
                            
                            updateSelectionInfo();
                            camera.detachControl(canvas);
                        } else {
                            console.log('No instance found for ID:', objectId);
                        }
                    } else {
                        // Clicked on ground or empty space
                        selectedObject = null;
                        updateSelectionInfo();
                        camera.attachControl(canvas, true);
                    }
                }
            };
            
            // Function to update the selected object UI
            function updateSelectedObjectUI() {
                if (selectedObject) {
                    document.getElementById('selected-id').textContent = selectedObject.id;
                    document.getElementById('selected-position').textContent =
                        `X: ${selectedObject.position.x.toFixed(2)}, Z: ${selectedObject.position.z.toFixed(2)}`;
                    document.getElementById('selected-rotation').textContent =
                        `${(selectedObject.rotation.y * 180 / Math.PI).toFixed(0)}¬∞`;
                } else {
                    document.getElementById('selected-id').textContent = 'None';
                    document.getElementById('selected-position').textContent = 'X: 0.00, Z: 0.00';
                    document.getElementById('selected-rotation').textContent = '0¬∞';
                }
            }
            
            return scene;
        };

        const init = () => {
            canvas = document.getElementById('renderCanvas');
            engine = new BABYLON.Engine(canvas, true);
            
            const scene = createScene();
            mapEngine = new MapEngine(scene);
            
            setupControls();
            initToolbox();
            
            // Setup keyboard events
            window.addEventListener('keydown', handleKeyboardInput);
            window.addEventListener('keyup', (event) => {
                if (event.key === 'Shift') {
                    isShiftPressed = false;
                }
            });
            
            engine.runRenderLoop(() => scene.render());
            window.addEventListener('resize', () => engine.resize());
        };

        const setupControls = () => {
            const loadMapBtn = document.getElementById('loadMapBtn');
            const reloadMapBtn = document.getElementById('reloadMapBtn');
            const saveMapBtn = document.getElementById('saveMapBtn');
            const mapSelect = document.getElementById('mapSelect');
            const saveMapName = document.getElementById('saveMapName');
            const showGridCheck = document.getElementById('showGrid');
            const gridSizeInput = document.getElementById('gridSize');
            const status = document.getElementById('status');
            
            loadMapBtn.addEventListener('click', async () => {
                try {
                    status.textContent = 'Loading map...';
                    console.log('Loading map data...');
                    await mapEngine.loadMapData(mapSelect.value);
                    console.log('Rendering map...');
                    await mapEngine.renderMap();
                    status.textContent = 'Map loaded successfully!';
                    saveMapName.value = mapSelect.options[mapSelect.selectedIndex].text;
                } catch (error) {
                    const errorMessage = `Error: ${error.message}. Check console for details.`;
                    status.textContent = errorMessage;
                    status.style.color = '#ff4444';
                    console.error('Error in map loading:', error);
                }
            });
            
            reloadMapBtn.addEventListener('click', async () => {
                try {
                    status.textContent = 'Reloading map...';
                    console.log('Reloading map data...');
                    await mapEngine.loadMapData(mapSelect.value);
                    console.log('Re-rendering map...');
                    await mapEngine.renderMap();
                    status.textContent = 'Map reloaded successfully!';
                } catch (error) {
                    const errorMessage = `Error: ${error.message}. Check console for details.`;
                    status.textContent = errorMessage;
                    status.style.color = '#ff4444';
                    console.error('Error in map reloading:', error);
                }
            });

            saveMapBtn.addEventListener('click', async () => {
                const mapName = saveMapName.value.trim() || 'Demo Map';
                status.textContent = 'Saving map...';
                
                try {
                    await mapEngine.saveMap(mapName);
                    
                    // Add to dropdown if it's a new map
                    const exists = Array.from(mapSelect.options).some(option => 
                        option.text === mapName
                    );
                    
                    if (!exists) {
                        const option = new Option(mapName, `maps/${mapName.toLowerCase().replace(/\s+/g, '_')}.json`);
                        mapSelect.add(option);
                    }
                    
                    status.textContent = `Map saved successfully as "${mapName}"`;
                    status.style.color = '#4CAF50';
                } catch (error) {
                    status.textContent = `Error saving map: ${error.message}`;
                    status.style.color = '#ff4444';
                    console.error('Error saving map:', error);
                }
            });
            
            showGridCheck.addEventListener('change', () => {
                ground.material = showGridCheck.checked ? gridMaterial : null;
            });
            
            gridSizeInput.addEventListener('change', () => {
                const size = parseFloat(gridSizeInput.value);
                if (size > 0) {
                    gridMaterial.gridRatio = size;
                    gridMaterial.majorUnitFrequency = 5 / size;
                }
            });
        };

        // Initialize the application
        window.addEventListener('DOMContentLoaded', () => {
            init();
        });
    </script>
</body>
</html> 